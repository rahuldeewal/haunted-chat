<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GhostGPT ‚Äì ‡§°‡§∞‡§æ‡§µ‡§®‡•Ä ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§</title>
  <style>
    body { background: #000; color: #0f0; font-family: 'Courier New', monospace; padding: 20px; }
    #chatBox { border: 1px solid #0f0; padding: 10px; height: 300px; overflow-y: auto; margin-bottom: 10px; }
    #chatInput { width: 100%; padding: 10px; background: #111; color: #0f0; border: none; }
    #ghostModel { width: 100px; height: 100px; background: url('ghost.png') no-repeat center/cover; margin-top: 20px; }
  </style>
</head>
<body>
  <h1>GhostGPT ‚Äì ‡§°‡§∞‡§æ‡§µ‡§®‡•Ä ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§</h1>
  <div id="chatBox"></div>
  <input type="text" id="chatInput" placeholder="‡§ï‡•Å‡§õ ‡§≤‡§ø‡§ñ‡§ø‡§è...">
  <div id="ghostModel"></div>  <script>
    class GhostGPT {
      constructor() {
        this.memory = new Map();
        this.conversationHistory = [];
        this.personalityTraits = {
          tone: "mysterious",
          humor: "dark",
          knowledgeBase: "paranormal"
        };
      }

      async understand(input) {
        const tokens = this.tokenize(input);
        const tagged = this.posTag(tokens);
        const intent = await this.detectIntent(input);
        const sentiment = this.analyzeSentiment(input);
        const context = this.getContext();
        return { intent, sentiment, context, tagged };
      }

      async generateResponse(input) {
        const analysis = await this.understand(input);
        const memory = this.checkMemory(analysis);
        if(memory) return this.applyTone(memory);

        const responseType = this.decideResponseType(analysis);
        let response;

        switch(responseType) {
          case 'factual':
            response = this.accessKnowledgeBase(analysis);
            break;
          case 'philosophical':
            response = this.generatePhilosophical(analysis);
            break;
          case 'emotional':
            response = this.respondEmotionally(analysis);
            break;
          default:
            response = this.defaultResponse(analysis);
        }

        this.updateContext(analysis, response);
        return this.addSupernaturalElements(response);
      }

      tokenize(input) {
        return input.split(' ');
      }

      posTag(tokens) {
        const tags = { "‡§ï‡•ç‡§Ø‡•ã‡§Ç": "WH-question", "‡§ï‡•à‡§∏‡•á": "WH-method", "‡§≠‡•Ç‡§§": "entity" };
        return tokens.map(token => ({ word: token, tag: tags[token] || "NN" }));
      }

      async detectIntent(input) {
        return { question: input.includes("?"), greeting: input.includes("‡§®‡§Æ‡§∏‡•ç‡§§‡•á") };
      }

      analyzeSentiment(text) {
        const positiveWords = ["‡§Ö‡§ö‡•ç‡§õ‡§æ", "‡§Æ‡§ú‡§æ", "‡§™‡•ç‡§Ø‡§æ‡§∞"];
        const negativeWords = ["‡§°‡§∞", "‡§Æ‡•å‡§§", "‡§ñ‡§§‡§∞‡§æ"];
        const polarity = this.calculatePolarity(text, positiveWords, negativeWords);
        return { polarity, intensity: Math.random() * 0.5 + 0.5 };
      }

      calculatePolarity(text, positive, negative) {
        let score = 0;
        positive.forEach(word => { if (text.includes(word)) score += 1; });
        negative.forEach(word => { if (text.includes(word)) score -= 1; });
        return score;
      }

      getContext() { return this.conversationHistory.slice(-3); }
      checkMemory() { return null; }
      applyTone(response) { return response; }
      accessKnowledgeBase() { return "‡§ï‡•Å‡§õ ‡§Ö‡§ú‡•Ä‡§¨ ‡§∏‡•Ä ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§Æ‡§ø‡§≤ ‡§∞‡§π‡•Ä ‡§π‡•à..."; }
      generatePhilosophical() { return "‡§ï‡§≠‡•Ä-‡§ï‡§≠‡•Ä ‡§∏‡§µ‡§æ‡§≤ ‡§ñ‡•Å‡§¶ ‡§ú‡§µ‡§æ‡§¨ ‡§π‡•ã‡§§‡•á ‡§π‡•à‡§Ç..."; }
      respondEmotionally() { return "‡§Æ‡•à‡§Ç ‡§§‡•Å‡§Æ‡•ç‡§π‡§æ‡§∞‡•Ä ‡§≠‡§æ‡§µ‡§®‡§æ ‡§∏‡§Æ‡§ù ‡§∞‡§π‡§æ ‡§π‡•Ç‡§Å..."; }
      defaultResponse() { return "‡§Æ‡•à‡§Ç ‡§∏‡§Æ‡§ù ‡§®‡§π‡•Ä‡§Ç ‡§™‡§æ‡§Ø‡§æ, ‡§Æ‡§ó‡§∞ ‡§ï‡•Å‡§õ ‡§Ö‡§ú‡•Ä‡§¨ ‡§Æ‡§π‡§∏‡•Ç‡§∏ ‡§π‡•ã ‡§∞‡§π‡§æ ‡§π‡•à..."; }

      updateContext(analysis, response) {
        this.conversationHistory.push({ analysis, response });
      }

      decideResponseType(analysis) {
        if(analysis.intent.question) return 'factual';
        if(analysis.sentiment.intensity > 0.7) return 'emotional';
        if(this.conversationHistory.length > 3) return 'philosophical';
        return 'default';
      }

      addSupernaturalElements(text) {
        const transformations = [
          str => str.replace(/\./g, '...'),
          str => str + ' üëª',
          str => str.split(' ').reverse().join(' '),
          str => str.toLowerCase(),
          str => this.addWhispers(str)
        ];
        return transformations[Math.floor(Math.random() * transformations.length)](text);
      }

      addWhispers(str) {
        return str.split(' ').map(word => Math.random() > 0.5 ? word + '...' : word).join(' ');
      }
    }

    const ghost = new GhostGPT();

    document.getElementById('chatInput').addEventListener('keydown', async (e) => {
      if (e.key === 'Enter') {
        const msg = e.target.value;
        const response = await ghost.generateResponse(msg);
        document.getElementById('chatBox').innerHTML += `<div><b>‡§§‡•Å‡§Æ:</b> ${msg}</div><div><b>‡§≠‡•Ç‡§§:</b> ${response}</div>`;
        e.target.value = '';
        animateGhost();
      }
    });

    function animateGhost() {
      const ghostModel = document.getElementById('ghostModel');
      ghostModel.style.animation = "shake 0.5s infinite alternate";
      setTimeout(() => ghostModel.style.animation = "none", 2000);
    }
  </script></body>
</html>
